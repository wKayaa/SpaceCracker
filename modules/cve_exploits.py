#!/usr/bin/env python3
"""
CVE Exploitation Engine
Tests for known CVEs from 2024-2025 with modular exploit system
"""

import asyncio
import aiohttp
import logging
import json
import re
from urllib.parse import urljoin, urlparse
import base64

class CVEExploits:
    """CVE exploitation engine with modular exploits"""
    
    def __init__(self, config):
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # CVE exploits database
        self.exploits = {
            # Kubernetes CVEs
            'CVE-2024-3177': {
                'name': 'Kubernetes kube-audit-rest exposure',
                'description': 'Exposed audit logs with potential secrets',
                'paths': [
                    '/api/v1/audit',
                    '/audit',
                    '/k8s/audit',
                    '/kubernetes/audit',
                    '/api/audit'
                ],
                'method': 'GET',
                'indicators': ['audit', 'kubernetes', 'apiVersion'],
                'severity': 'high'
            },
            
            'CVE-2024-4068': {
                'name': 'Karmada pull mode vulnerability',
                'description': 'Privilege escalation in Karmada deployments',
                'paths': [
                    '/api/v1alpha1/clusters',
                    '/karmada/api',
                    '/api/cluster.karmada.io',
                    '/clusters'
                ],
                'method': 'GET',
                'indicators': ['karmada', 'cluster.karmada.io', 'clusters'],
                'severity': 'high'
            },
            
            'CVE-2024-7646': {
                'name': 'Ingress-NGINX auth-url injection',
                'description': 'RCE through auth-url annotation injection',
                'paths': [
                    '/nginx-status',
                    '/nginx_status',
                    '/stub_status',
                    '/api/v1/ingresses',
                    '/ingress'
                ],
                'method': 'GET',
                'indicators': ['nginx', 'ingress', 'active connections'],
                'severity': 'critical'
            },
            
            # MinIO CVEs
            'CVE-2024-8572': {
                'name': 'MinIO AssumeRoleWithWebIdentity',
                'description': 'Authentication bypass in MinIO',
                'paths': [
                    '/minio/health/ready',
                    '/minio/health/live',
                    '/minio/prometheus/metrics',
                    '/minio/v2/metrics/cluster',
                    '/minio/admin/v3/info'
                ],
                'method': 'GET',
                'indicators': ['minio', 'MinIO', 'S3 compatible'],
                'severity': 'high'
            },
            
            # Container/Docker CVEs
            'CVE-2024-1313': {
                'name': 'Docker daemon exposure',
                'description': 'Exposed Docker daemon API',
                'paths': [
                    '/v1.40/info',
                    '/v1.41/info',
                    '/version',
                    '/info',
                    '/_ping',
                    '/containers/json'
                ],
                'method': 'GET',
                'indicators': ['docker', 'ApiVersion', 'containers'],
                'severity': 'critical'
            },
            
            # Generic API exposures
            'CVE-2024-GENERIC-API': {
                'name': 'Exposed API endpoints',
                'description': 'Various exposed API endpoints',
                'paths': [
                    '/api/health',
                    '/health',
                    '/status',
                    '/metrics',
                    '/actuator/health',
                    '/actuator/info',
                    '/actuator/env',
                    '/actuator/configprops',
                    '/monitoring',
                    '/admin/status',
                    '/debug/vars'
                ],
                'method': 'GET',
                'indicators': ['status', 'health', 'metrics', 'actuator'],
                'severity': 'medium'
            }
        }
        
    async def scan(self, session, target):
        """Main CVE scanning function"""
        results = []
        
        try:
            # Test each CVE exploit
            for cve_id, exploit in self.exploits.items():
                exploit_results = await self._test_exploit(session, target, cve_id, exploit)
                if exploit_results:
                    results.extend(exploit_results)
                    
        except Exception as e:
            self.logger.error(f"CVE Scanner error for {target}: {e}")
            
        return results
        
    async def _test_exploit(self, session, target, cve_id, exploit):
        """Test a specific CVE exploit"""
        results = []
        
        for path in exploit['paths']:
            try:
                url = urljoin(target, path)
                
                # Prepare request based on method
                request_kwargs = {'url': url}
                if exploit.get('headers'):
                    request_kwargs['headers'] = exploit['headers']
                if exploit.get('data'):
                    request_kwargs['json'] = exploit['data']
                    
                # Execute request
                method = exploit.get('method', 'GET').lower()
                request_func = getattr(session, method)
                
                async with request_func(**request_kwargs) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for vulnerability indicators
                        content_lower = content.lower()
                        found_indicators = [
                            ind for ind in exploit['indicators'] 
                            if ind.lower() in content_lower
                        ]
                        
                        if found_indicators:
                            result = {
                                'module': 'cve_exploits',
                                'type': 'cve_vulnerability',
                                'cve_id': cve_id,
                                'name': exploit['name'],
                                'description': exploit['description'],
                                'url': url,
                                'base_target': target,
                                'status': response.status,
                                'method': exploit['method'],
                                'indicators_found': found_indicators,
                                'severity': exploit['severity'],
                                'content_length': len(content),
                                'headers': dict(response.headers)
                            }
                            
                            # Extract specific information based on CVE type
                            extracted_data = await self._extract_cve_data(cve_id, content, session, url)
                            if extracted_data:
                                result['extracted_data'] = extracted_data
                                
                            results.append(result)
                            
                    elif response.status in [401, 403]:
                        # Authentication required - still a finding
                        result = {
                            'module': 'cve_exploits',
                            'type': 'cve_auth_required',
                            'cve_id': cve_id,
                            'name': exploit['name'],
                            'url': url,
                            'base_target': target,
                            'status': response.status,
                            'severity': 'medium',
                            'note': 'Endpoint exists but requires authentication'
                        }
                        results.append(result)
                        
            except Exception as e:
                self.logger.debug(f"Error testing {cve_id} on {path}: {e}")
                
        return results
        
    async def _extract_cve_data(self, cve_id, content, session, url):
        """Extract specific data based on CVE type"""
        extracted = {}
        
        try:
            if 'audit' in cve_id.lower():
                # Extract audit log information
                audit_patterns = [
                    r'"user":\s*"([^"]+)"',
                    r'"verb":\s*"([^"]+)"',
                    r'"resource":\s*"([^"]+)"',
                    r'"namespace":\s*"([^"]+)"'
                ]
                
                for pattern in audit_patterns:
                    matches = re.findall(pattern, content)
                    if matches:
                        key = pattern.split('"')[1]
                        extracted[f'audit_{key}'] = list(set(matches))
                        
            elif 'docker' in cve_id.lower():
                # Extract Docker information
                try:
                    import json
                    data = json.loads(content)
                    if isinstance(data, dict):
                        extracted['docker_info'] = {
                            'version': data.get('Version'),
                            'api_version': data.get('ApiVersion'),
                            'os': data.get('Os'),
                            'arch': data.get('Arch'),
                            'containers': data.get('Containers'),
                            'images': data.get('Images')
                        }
                except:
                    pass
                    
            elif 'minio' in cve_id.lower():
                # Extract MinIO information
                minio_patterns = [
                    r'"version":\s*"([^"]+)"',
                    r'"region":\s*"([^"]+)"',
                    r'"buckets":\s*(\d+)',
                    r'"objects":\s*(\d+)'
                ]
                
                for pattern in minio_patterns:
                    matches = re.findall(pattern, content)
                    if matches:
                        key = pattern.split('"')[1] if '"' in pattern else 'count'
                        extracted[f'minio_{key}'] = matches[0]
                        
            elif 'karmada' in cve_id.lower():
                # Extract Karmada cluster information
                cluster_patterns = [
                    r'"name":\s*"([^"]+)"',
                    r'"cluster":\s*"([^"]+)"',
                    r'"endpoint":\s*"([^"]+)"'
                ]
                
                for pattern in cluster_patterns:
                    matches = re.findall(pattern, content)
                    if matches:
                        key = pattern.split('"')[1]
                        extracted[f'karmada_{key}'] = list(set(matches))
                        
            elif 'nginx' in cve_id.lower():
                # Extract NGINX status information
                nginx_patterns = [
                    r'Active connections:\s*(\d+)',
                    r'server accepts handled requests\s*(\d+\s+\d+\s+\d+)',
                    r'Reading:\s*(\d+).*Writing:\s*(\d+).*Waiting:\s*(\d+)'
                ]
                
                for pattern in nginx_patterns:
                    matches = re.findall(pattern, content)
                    if matches:
                        if 'connections' in pattern:
                            extracted['nginx_active_connections'] = matches[0]
                        elif 'accepts' in pattern:
                            extracted['nginx_stats'] = matches[0]
                        elif 'Reading' in pattern:
                            extracted['nginx_connection_states'] = matches[0]
                            
            # Generic secret extraction for all CVEs
            secrets = self._extract_secrets_from_content(content)
            if secrets:
                extracted['secrets'] = secrets
                
        except Exception as e:
            self.logger.debug(f"Error extracting CVE data for {cve_id}: {e}")
            
        return extracted if extracted else None
        
    def _extract_secrets_from_content(self, content):
        """Extract secrets from content"""
        secrets = {}
        
        # Common secret patterns
        secret_patterns = {
            'api_keys': [
                r'["\']?api[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9]{20,})["\']',
                r'["\']?apikey["\']?\s*[:=]\s*["\']([a-zA-Z0-9]{20,})["\']'
            ],
            'tokens': [
                r'["\']?token["\']?\s*[:=]\s*["\']([a-zA-Z0-9._-]{20,})["\']',
                r'["\']?access[_-]?token["\']?\s*[:=]\s*["\']([a-zA-Z0-9._-]{20,})["\']'
            ],
            'passwords': [
                r'["\']?password["\']?\s*[:=]\s*["\']([^"\']{8,})["\']',
                r'["\']?passwd["\']?\s*[:=]\s*["\']([^"\']{8,})["\']'
            ],
            'database_urls': [
                r'mongodb://[^"\'\s]+',
                r'mysql://[^"\'\s]+',
                r'postgresql://[^"\'\s]+'
            ],
            'aws_keys': [
                r'AKIA[0-9A-Z]{16}',
                r'aws[_-]?access[_-]?key["\']?\s*[:=]\s*["\']([^"\']+)["\']'
            ]
        }
        
        for secret_type, patterns in secret_patterns.items():
            found_secrets = []
            for pattern in patterns:
                matches = re.finditer(pattern, content, re.IGNORECASE)
                for match in matches:
                    if match.groups():
                        found_secrets.append(match.group(1))
                    else:
                        found_secrets.append(match.group(0))
                        
            if found_secrets:
                secrets[secret_type] = list(set(found_secrets))  # Remove duplicates
                
        return secrets if secrets else None
        
    def add_custom_exploit(self, cve_id, exploit_config):
        """Add a custom exploit to the database"""
        self.exploits[cve_id] = exploit_config
        self.logger.info(f"Added custom exploit: {cve_id}")
        
    def list_available_exploits(self):
        """List all available exploits"""
        return {cve_id: exploit['name'] for cve_id, exploit in self.exploits.items()}